#include <iostream>
#include <string>
#include <string_view>
#include <random>
#include <vector>
#include <unordered_set>
#include <unordered_map>
#include <set>
#include <map>
#include <algorithm>
#include <chrono>
#include <fstream>
#include <sstream>

#include <benchmark/benchmark.h>

#include "german_string.h"

constexpr auto SMALL_KNOWN_STRING = "Hello World";
constexpr auto MEDIUM_KNOWN_STRING = "The quick brown fox jumps over the lazy dog and then continues running through the forest.";
constexpr auto LARGE_KNOWN_STRING = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.";

// Common string patterns for realistic benchmarks
const std::vector<std::string> COMMON_PREFIXES = {
    "https://", "http://", "file://", "data:",
    "user_", "admin_", "guest_", "system_",
    "GET ", "POST ", "PUT ", "DELETE ",
    "ERROR:", "WARNING:", "INFO:", "DEBUG:",
    "/home/", "/usr/", "/var/", "/tmp/"
};

const std::vector<std::string> COMMON_SUFFIXES = {
    ".txt", ".cpp", ".h", ".json", ".xml",
    "_backup", "_temp", "_old", "_new",
    "?query=1", "&param=value", "#section",
    ".log", ".dat", ".bin"
};

template <typename StringType>
std::vector<StringType> generate_random_strings(size_t count, uint32_t min_length, uint32_t max_length, uint32_t seed)
{
    std::vector<StringType> strings;
    strings.reserve(count);
    std::string alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+[]{}|;:,.<>?/-_";
    std::mt19937 generator(seed);
    std::uniform_int_distribution<> length_distribution(min_length, max_length);
    std::uniform_int_distribution<> char_distribution(0, static_cast<int>(alphabet.size() - 1));

    constexpr float small_known_string_probability = 0.08f;
    constexpr float medium_known_string_probability = 0.05f;
    constexpr float large_known_string_probability = 0.03f;
    constexpr float common_pattern_probability = 0.15f;
    std::uniform_real_distribution<> known_string_distribution(0.0f, 1.0f);
    std::uniform_int_distribution<> prefix_distribution(0, static_cast<int>(COMMON_PREFIXES.size() - 1));
    std::uniform_int_distribution<> suffix_distribution(0, static_cast<int>(COMMON_SUFFIXES.size() - 1));

    for (size_t i = 0; i < count; ++i)
    {
        float rand_val = known_string_distribution(generator);
        
        if (rand_val < small_known_string_probability)
        {
            strings.emplace_back(SMALL_KNOWN_STRING);
            continue;
        }
        else if (rand_val < small_known_string_probability + medium_known_string_probability)
        {
            strings.emplace_back(MEDIUM_KNOWN_STRING);
            continue;
        }
        else if (rand_val < small_known_string_probability + medium_known_string_probability + large_known_string_probability)
        {
            strings.emplace_back(LARGE_KNOWN_STRING);
            continue;
        }
        else if (rand_val < small_known_string_probability + medium_known_string_probability + large_known_string_probability + common_pattern_probability)
        {
            // Generate strings with common patterns
            std::string pattern_string = COMMON_PREFIXES[prefix_distribution(generator)];
            size_t remaining_length = std::max(0, static_cast<int>(length_distribution(generator)) - static_cast<int>(pattern_string.length()));
            for (size_t j = 0; j < remaining_length; ++j)
            {
                pattern_string += alphabet[char_distribution(generator)];
            }
            if (rand_val > 0.5f) // 50% chance to add suffix
            {
                pattern_string += COMMON_SUFFIXES[suffix_distribution(generator)];
            }
            strings.emplace_back(pattern_string.c_str());
            continue;
        }

        // Generate completely random string
        std::string new_built_string;
        size_t length = length_distribution(generator);
        for (size_t j = 0; j < length; ++j)
        {
            new_built_string += alphabet[char_distribution(generator)];
        }
        strings.emplace_back(new_built_string.c_str());
    }
    return strings;
}

// 1. Construction Benchmarks
template <typename StringType>
void StringConstruction(benchmark::State &state)
{
    size_t count = state.range(0);
    uint32_t string_length = static_cast<uint32_t>(state.range(1));
    uint32_t seed = static_cast<uint32_t>(state.range(2));
    
    auto random_strings = generate_random_strings<std::string>(count, string_length, string_length, seed);
    
    for (auto _ : state)
    {
        std::vector<StringType> strings;
        strings.reserve(count);
        for (const auto &str : random_strings)
        {
            strings.emplace_back(str.c_str());
        }
        benchmark::DoNotOptimize(strings);
        benchmark::ClobberMemory();
    }
    
    state.SetItemsProcessed(state.iterations() * count);
    state.SetBytesProcessed(state.iterations() * count * string_length);
}

BENCHMARK_TEMPLATE(StringConstruction, std::string)
    ->Args({1000, 16, 42})
    ->Args({1000, 64, 42})
    ->Args({1000, 256, 42})
    ->Args({10000, 16, 42})
    ->Args({10000, 64, 42});

BENCHMARK_TEMPLATE(StringConstruction, gs::german_string)
    ->Args({1000, 16, 42})
    ->Args({1000, 64, 42})
    ->Args({1000, 256, 42})
    ->Args({10000, 16, 42})
    ->Args({10000, 64, 42});

// 2. Copy Construction Benchmarks
template <typename StringType>
void StringCopyConstruction(benchmark::State &state)
{
    size_t count = state.range(0);
    uint32_t string_length = static_cast<uint32_t>(state.range(1));
    uint32_t seed = static_cast<uint32_t>(state.range(2));
    
    auto strings = generate_random_strings<StringType>(count, string_length, string_length, seed);
    
    for (auto _ : state)
    {
        std::vector<StringType> copied_strings;
        copied_strings.reserve(count);
        for (const auto &str : strings)
        {
            copied_strings.emplace_back(str);
        }
        benchmark::DoNotOptimize(copied_strings);
        benchmark::ClobberMemory();
    }
    
    state.SetItemsProcessed(state.iterations() * count);
    state.SetBytesProcessed(state.iterations() * count * string_length);
}

BENCHMARK_TEMPLATE(StringCopyConstruction, std::string)
    ->Args({1000, 16, 42})
    ->Args({1000, 256, 42})
    ->Args({10000, 64, 42});

BENCHMARK_TEMPLATE(StringCopyConstruction, gs::german_string)
    ->Args({1000, 16, 42})
    ->Args({1000, 256, 42})
    ->Args({10000, 64, 42});

// 3. Hash Map Performance
template <typename StringType>
void StringHashMapInsertion(benchmark::State &state)
{
    size_t count = state.range(0);
    uint32_t min_length = static_cast<uint32_t>(state.range(1));
    uint32_t max_length = static_cast<uint32_t>(state.range(2));
    uint32_t seed = static_cast<uint32_t>(state.range(3));
    
    auto strings = generate_random_strings<StringType>(count, min_length, max_length, seed);
    
    for (auto _ : state)
    {
        std::unordered_map<StringType, int> hash_map;
        hash_map.reserve(count);
        for (size_t i = 0; i < strings.size(); ++i)
        {
            hash_map[strings[i]] = static_cast<int>(i);
        }
        benchmark::DoNotOptimize(hash_map);
        benchmark::ClobberMemory();
    }
    
    state.SetItemsProcessed(state.iterations() * count);
}

BENCHMARK_TEMPLATE(StringHashMapInsertion, std::string)
    ->Args({1000, 8, 128, 42})
    ->Args({10000, 8, 128, 42})
    ->Args({50000, 8, 128, 42});

BENCHMARK_TEMPLATE(StringHashMapInsertion, gs::german_string)
    ->Args({1000, 8, 128, 42})
    ->Args({10000, 8, 128, 42})
    ->Args({50000, 8, 128, 42});

// 4. Hash Map Lookup Performance
template <typename StringType>
void StringHashMapLookup(benchmark::State &state)
{
    size_t count = state.range(0);
    uint32_t min_length = static_cast<uint32_t>(state.range(1));
    uint32_t max_length = static_cast<uint32_t>(state.range(2));
    uint32_t seed = static_cast<uint32_t>(state.range(3));
    
    auto strings = generate_random_strings<StringType>(count, min_length, max_length, seed);
    std::unordered_map<StringType, int> hash_map;
    hash_map.reserve(count);
    for (size_t i = 0; i < strings.size(); ++i)
    {
        hash_map[strings[i]] = static_cast<int>(i);
    }
    
    std::mt19937 lookup_gen(seed + 1000);
    std::uniform_int_distribution<> lookup_dist(0, static_cast<int>(strings.size() - 1));
    
    for (auto _ : state)
    {
        int total = 0;
        for (int i = 0; i < 1000; ++i)
        {
            auto it = hash_map.find(strings[lookup_dist(lookup_gen)]);
            if (it != hash_map.end())
            {
                total += it->second;
            }
        }
        benchmark::DoNotOptimize(total);
        benchmark::ClobberMemory();
    }
    
    state.SetItemsProcessed(state.iterations() * 1000);
}

BENCHMARK_TEMPLATE(StringHashMapLookup, std::string)
    ->Args({1000, 8, 128, 42})
    ->Args({10000, 8, 128, 42})
    ->Args({50000, 8, 128, 42});

BENCHMARK_TEMPLATE(StringHashMapLookup, gs::german_string)
    ->Args({1000, 8, 128, 42})
    ->Args({10000, 8, 128, 42})
    ->Args({50000, 8, 128, 42});

// 5. Set Operations (Ordered)
template <typename StringType>
void StringSetInsertion(benchmark::State &state)
{
    size_t count = state.range(0);
    uint32_t min_length = static_cast<uint32_t>(state.range(1));
    uint32_t max_length = static_cast<uint32_t>(state.range(2));
    uint32_t seed = static_cast<uint32_t>(state.range(3));
    
    auto strings = generate_random_strings<StringType>(count, min_length, max_length, seed);
    
    for (auto _ : state)
    {
        std::set<StringType> string_set;
        for (const auto &str : strings)
        {
            string_set.insert(str);
        }
        benchmark::DoNotOptimize(string_set);
        benchmark::ClobberMemory();
    }
    
    state.SetItemsProcessed(state.iterations() * count);
}

BENCHMARK_TEMPLATE(StringSetInsertion, std::string)
    ->Args({1000, 8, 128, 42})
    ->Args({10000, 8, 128, 42});

BENCHMARK_TEMPLATE(StringSetInsertion, gs::german_string)
    ->Args({1000, 8, 128, 42})
    ->Args({10000, 8, 128, 42});

// 6. String Length Scenarios
template <typename StringType>
void StringComparisonByLength(benchmark::State &state)
{
    uint32_t length = static_cast<uint32_t>(state.range(0));
    uint32_t seed = static_cast<uint32_t>(state.range(1));
    
    auto strings = generate_random_strings<StringType>(2000, length, length, seed);
    
    for (auto _ : state)
    {
        size_t equal_count = 0;
        for (size_t i = 0; i < strings.size(); i += 2)
        {
            if (i + 1 < strings.size() && strings[i] == strings[i + 1])
            {
                ++equal_count;
            }
        }
        benchmark::DoNotOptimize(equal_count);
        benchmark::ClobberMemory();
    }
    
    state.SetItemsProcessed(state.iterations() * (strings.size() / 2));
}

BENCHMARK_TEMPLATE(StringComparisonByLength, std::string)
    ->Arg(4)->Arg(8)->Arg(16)->Arg(32)->Arg(64)->Arg(128)->Arg(256)->Arg(512)->Arg(1024);

BENCHMARK_TEMPLATE(StringComparisonByLength, gs::german_string)
    ->Arg(4)->Arg(8)->Arg(16)->Arg(32)->Arg(64)->Arg(128)->Arg(256)->Arg(512)->Arg(1024);

// 7. Memory Usage Simulation
template <typename StringType>
void StringVectorResize(benchmark::State &state)
{
    size_t final_size = state.range(0);
    uint32_t string_length = static_cast<uint32_t>(state.range(1));
    uint32_t seed = static_cast<uint32_t>(state.range(2));
    
    auto template_strings = generate_random_strings<StringType>(100, string_length, string_length, seed);
    std::mt19937 gen(seed);
    std::uniform_int_distribution<> dist(0, static_cast<int>(template_strings.size() - 1));
    
    for (auto _ : state)
    {
        std::vector<StringType> strings;
        for (size_t i = 0; i < final_size; ++i)
        {
            strings.push_back(template_strings[dist(gen)]);
        }
        benchmark::DoNotOptimize(strings);
        benchmark::ClobberMemory();
    }
    
    state.SetItemsProcessed(state.iterations() * final_size);
}

BENCHMARK_TEMPLATE(StringVectorResize, std::string)
    ->Args({10000, 32, 42})
    ->Args({100000, 32, 42})
    ->Args({10000, 128, 42})
    ->Args({100000, 128, 42});

BENCHMARK_TEMPLATE(StringVectorResize, gs::german_string)
    ->Args({10000, 32, 42})
    ->Args({100000, 32, 42})
    ->Args({10000, 128, 42})
    ->Args({100000, 128, 42});

// 8. Substring and Search Operations
template <typename StringType>
void StringSearch(benchmark::State &state)
{
    size_t count = state.range(0);
    uint32_t string_length = static_cast<uint32_t>(state.range(1));
    uint32_t seed = static_cast<uint32_t>(state.range(2));
    
    auto strings = generate_random_strings<StringType>(count, string_length, string_length, seed);
    std::vector<StringType> search_terms;
    search_terms.reserve(100);
    
    // Create search terms from substrings of existing strings
    std::mt19937 gen(seed + 5000);
    std::uniform_int_distribution<> string_dist(0, static_cast<int>(strings.size() - 1));
    std::uniform_int_distribution<> pos_dist(0, std::max(0, static_cast<int>(string_length) - 4));
    
    for (int i = 0; i < 100; ++i)
    {
        const auto &source = strings[string_dist(gen)];
        if constexpr (std::is_same_v<StringType, std::string>)
        {
            int start_pos = pos_dist(gen);
            search_terms.emplace_back(source.substr(start_pos, 4));
        }
        else
        {
            // For german_string, we'd need to implement substr or use a different approach
            search_terms.emplace_back("test"); // placeholder
        }
    }
    
    for (auto _ : state)
    {
        size_t found_count = 0;
        for (const auto &search_term : search_terms)
        {
            for (const auto &str : strings)
            {
                if constexpr (std::is_same_v<StringType, std::string>)
                {
                    if (str.find(search_term) != std::string::npos)
                    {
                        ++found_count;
                    }
                }
                else
                {
                    // For german_string, implement basic equality check as placeholder
                    if (str == search_term)
                    {
                        ++found_count;
                    }
                }
            }
        }
        benchmark::DoNotOptimize(found_count);
        benchmark::ClobberMemory();
    }
    
    state.SetItemsProcessed(state.iterations() * search_terms.size() * strings.size());
}

BENCHMARK_TEMPLATE(StringSearch, std::string)
    ->Args({1000, 64, 42})
    ->Args({5000, 64, 42});

BENCHMARK_TEMPLATE(StringSearch, gs::german_string)
    ->Args({1000, 64, 42})
    ->Args({5000, 64, 42});

// 9. Different String Classes for german_string
void GermanStringClassComparison(benchmark::State &state)
{
    size_t count = state.range(0);
    uint32_t string_length = static_cast<uint32_t>(state.range(1));
    uint32_t seed = static_cast<uint32_t>(state.range(2));
    int string_class_type = static_cast<int>(state.range(3)); // 0=temporary, 1=persistent, 2=transient
    
    auto template_strings = generate_random_strings<std::string>(count, string_length, string_length, seed);
    
    for (auto _ : state)
    {
        std::vector<gs::german_string> strings;
        strings.reserve(count);
        
        for (const auto &str : template_strings)
        {
            switch (string_class_type)
            {
                case 0:
                    strings.emplace_back(str.c_str(), static_cast<uint32_t>(str.length()), gs::temporary_t{});
                    break;
                case 1:
                    strings.emplace_back(str.c_str(), static_cast<uint32_t>(str.length()), gs::persistent_t{});
                    break;
                case 2:
                    strings.emplace_back(str.c_str(), static_cast<uint32_t>(str.length()), gs::transient_t{});
                    break;
            }
        }
        benchmark::DoNotOptimize(strings);
        benchmark::ClobberMemory();
    }
    
    state.SetItemsProcessed(state.iterations() * count);
    state.SetLabel(string_class_type == 0 ? "temporary" : 
                   string_class_type == 1 ? "persistent" : "transient");
}

BENCHMARK(GermanStringClassComparison)
    ->Args({1000, 64, 42, 0})  // temporary
    ->Args({1000, 64, 42, 1})  // persistent  
    ->Args({1000, 64, 42, 2})  // transient
    ->Args({10000, 64, 42, 0}) // temporary
    ->Args({10000, 64, 42, 1}) // persistent
    ->Args({10000, 64, 42, 2}); // transient

BENCHMARK_MAIN();
